#!/usr/bin/env python3
"""
Interactive Shell for Equasis CLI with prompt_toolkit
Provides Claude Code-style TUI with fixed input area at bottom
"""

import re
import os
import sys
import logging
from typing import Dict, Optional, Tuple, List
from prompt_toolkit import PromptSession, HTML
from prompt_toolkit.completion import Completer, Completion
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.formatted_text import FormattedText
from prompt_toolkit.styles import Style
from prompt_toolkit.shortcuts import print_formatted_text

from .client import EquasisClient
from .formatter import OutputFormatter
from .banner import display_banner, display_credentials_note, check_credentials, Colors
from .credentials import get_credential_manager

logger = logging.getLogger(__name__)


class SlashCommandCompleter(Completer):
    """Auto-completion for slash parameters"""

    def __init__(self):
        self.command_params = {
            'vessel': ['/imo', '/format', '/output'],
            'search': ['/name', '/format', '/output'],
            'fleet': ['/company', '/format', '/output'],
            'batch': ['/imos', '/file', '/companies', '/company-file', '/format', '/output'],
            'format': [],  # No slash params, just format name
            'status': [],
            'clear': [],
            'help': [],
            'exit': [],
            'quit': [],
        }

    def get_completions(self, document, complete_event):
        """Generate completions based on current input"""
        text = document.text_before_cursor
        words = text.split()

        if not words:
            return

        # First word - complete command names
        if len(words) == 1 and not text.endswith(' '):
            for cmd in self.command_params.keys():
                if cmd.startswith(words[0]):
                    yield Completion(cmd, start_position=-len(words[0]))

        # Slash parameter completion
        elif '/' in text:
            # Find the command
            command = words[0] if words else ''
            if command in self.command_params:
                params = self.command_params[command]

                # Get the last partial slash param
                last_word = words[-1] if words else ''
                if last_word.startswith('/'):
                    for param in params:
                        if param.startswith(last_word):
                            yield Completion(param, start_position=-len(last_word))


class InteractiveShell:
    """Interactive shell with Claude Code-style TUI"""

    def __init__(self):
        self.client: Optional[EquasisClient] = None
        self.formatter = OutputFormatter()
        self.output_format = 'table'
        self.debug_mode = False
        self.logged_in = False
        self.running = True

        # Connection and status tracking
        self.connection_status = "Not connected"
        self.last_operation = ""

        # Setup prompt_toolkit session
        self.completer = SlashCommandCompleter()
        self.session = PromptSession(
            completer=self.completer,
            complete_while_typing=True,
            bottom_toolbar=self._get_bottom_toolbar,
        )

        # Color support
        self.color_support = Colors.supports_color()

        # Setup key bindings
        self.kb = KeyBindings()
        self._setup_key_bindings()

    def _setup_key_bindings(self):
        """Setup custom key bindings for ? help"""
        @self.kb.add('?')
        def _(event):
            """Show help overlay when ? is pressed alone"""
            buffer = event.app.current_buffer
            # Only show help if buffer is empty
            if not buffer.text:
                # Mark that we want to show help
                buffer.insert_text('?help')
            else:
                # Insert ? normally
                buffer.insert_text('?')

    def _get_bottom_toolbar(self):
        """Generate bottom toolbar content (status bar)"""
        parts = []

        # Connection status
        if self.logged_in:
            parts.append(('class:status-connected', '● Connected'))
        else:
            parts.append(('class:status-disconnected', '○ Not connected'))

        # Format
        parts.append(('class:status-dim', f' • Format: '))
        parts.append(('class:status-format', self.output_format))

        # Last operation
        if self.last_operation:
            parts.append(('class:status-dim', f' • {self.last_operation}'))
        else:
            parts.append(('class:status-dim', ' • Press ? for help'))

        return FormattedText(parts)

    def _get_style(self):
        """Define color style for prompt_toolkit (Atom One Dark inspired - text only, transparent backgrounds)"""
        return Style.from_dict({
            # Bottom toolbar - transparent background with noreverse to disable default reverse video
            'bottom-toolbar': 'fg:#abb2bf bg:default noreverse',  # Light text, transparent bg, no reverse
            'bottom-toolbar.text': 'bg:default noreverse',         # Transparent bg, no reverse

            # Status bar colors - text only, no background
            'status-connected': 'fg:#98c379 bg:default noreverse',    # Soft green text, transparent bg
            'status-disconnected': 'fg:#e06c75 bg:default noreverse', # Soft red text, transparent bg
            'status-dim': 'fg:#5c6370 bg:default noreverse',          # Muted gray text, transparent bg
            'status-format': 'fg:#61afef bg:default noreverse',       # Soft blue text, transparent bg
            'status-warning': 'fg:#e5c07b bg:default noreverse',      # Soft yellow text, transparent bg
            'prompt': 'fg:#61afef bg:default noreverse',              # Soft blue text for prompt, transparent bg

            # Completion menu - transparent backgrounds everywhere
            'completion-menu': 'bg:default noreverse',                            # Transparent background
            'completion-menu.completion': 'fg:#abb2bf bg:default noreverse',      # Light text, transparent bg
            'completion-menu.completion.current': 'fg:#61afef bold bg:default noreverse', # Bright blue bold, transparent bg
            'completion-menu.meta': 'fg:#5c6370 bg:default noreverse',            # Dim text, transparent bg
            'scrollbar.background': 'bg:default noreverse',                       # Transparent scrollbar
            'scrollbar.button': 'bg:default noreverse',                           # Transparent scrollbar button
        })

    def _print(self, text: str, style: str = ''):
        """Print text with optional style"""
        if style and self.color_support:
            print_formatted_text(HTML(text))
        else:
            # Strip HTML tags for non-color terminals
            clean_text = re.sub('<[^<]+?>', '', text)
            print(clean_text)

    def _print_separator(self):
        """Print horizontal separator"""
        try:
            import shutil
            width = shutil.get_terminal_size().columns
        except:
            width = 80

        if self.color_support:
            print_formatted_text(FormattedText([('class:status-dim', '─' * width)]), style=self._get_style())
        else:
            print('─' * width)

    def _show_help_overlay(self):
        """Show help overlay (triggered by ?)"""
        self._print_separator()
        if self.color_support:
            self._print('<cyan><b>AVAILABLE COMMANDS</b></cyan>')
        else:
            print('AVAILABLE COMMANDS')
        self._print_separator()

        commands = [
            ('vessel', 'Get vessel information by IMO'),
            ('search', 'Search vessels by name'),
            ('fleet', 'Get company fleet information'),
            ('batch', 'Process multiple vessels/companies'),
            ('format', 'Set default output format'),
            ('status', 'Show connection status'),
            ('clear', 'Clear terminal screen'),
            ('help', 'Show detailed help for command'),
            ('exit', 'Exit interactive mode'),
        ]

        for cmd, desc in commands:
            if self.color_support:
                self._print(f'  <cyan>{cmd:10}</cyan> <dim>{desc}</dim>')
            else:
                print(f'  {cmd:10} {desc}')

        self._print_separator()
        print()

    def start(self):
        """Start the interactive shell"""
        # Suppress verbose logging from client during interactive use
        logging.getLogger('equasis_cli.client').setLevel(logging.WARNING)

        # Show banner
        display_banner(show_banner=True, show_info=True)
        print()

        if self.color_support:
            print_formatted_text(FormattedText([('class:status-dim', "Type 'help' for available commands or 'exit' to quit.")]), style=self._get_style())
            print_formatted_text(FormattedText([('class:status-dim', "Use /output with any command to save results to a file.")]), style=self._get_style())
        else:
            print("Type 'help' for available commands or 'exit' to quit.")
            print("Use /output with any command to save results to a file.")
        print()

        # Main loop
        while self.running:
            try:
                # Get input with bottom toolbar (no separators yet)
                user_input = self.session.prompt(
                    FormattedText([('class:prompt', '> ')]),
                    style=self._get_style(),
                    key_bindings=self.kb,
                )

                # Empty line - just continue to next prompt
                if not user_input.strip():
                    continue

                # Handle special ?help command (triggered by ? key)
                if user_input.strip() == '?help':
                    # Clear screen and show help
                    os.system('clear' if os.name == 'posix' else 'cls')
                    self._show_help_overlay()
                    continue

                # Now we have a real command - show output area with separators
                print()  # Blank line after input
                self._print_separator()
                print()

                # Process command (output appears here)
                self._process_command(user_input.strip())

                print()
                self._print_separator()
                print()  # Extra spacing before next prompt

            except KeyboardInterrupt:
                # Clear the input line on Ctrl+C
                print('\033[F\033[K', end='')
                continue
            except EOFError:
                self._do_exit()
                break
            except Exception as e:
                logger.error(f"Error in main loop: {e}", exc_info=True)
                if self.color_support:
                    print_formatted_text(FormattedText([('class:status-disconnected', f'Error: {e}')]), style=self._get_style())
                else:
                    print(f"Error: {e}")

    def _process_command(self, line: str):
        """Process a command line"""
        # Parse command
        parts = line.split(maxsplit=1)
        if not parts:
            return

        command = parts[0].lower()
        args = parts[1] if len(parts) > 1 else ''

        # Route to command handlers
        command_map = {
            'vessel': self._cmd_vessel,
            'search': self._cmd_search,
            'fleet': self._cmd_fleet,
            'batch': self._cmd_batch,
            'format': self._cmd_format,
            'status': self._cmd_status,
            'clear': self._cmd_clear,
            'help': self._cmd_help,
            'output': self._cmd_output_help,
            'exit': self._cmd_exit,
            'quit': self._cmd_exit,
        }

        handler = command_map.get(command)
        if handler:
            handler(args)
        else:
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', f'Unknown command: {command}')]), style=self._get_style())
                print_formatted_text(FormattedText([('class:status-dim', "Type 'help' for available commands")]), style=self._get_style())
            else:
                print(f"Unknown command: {command}")
                print("Type 'help' for available commands")

    def parse_slash_command(self, line: str, expected_params: Dict[str, bool]) -> Tuple[Dict[str, str], bool]:
        """
        Parse slash parameters like /imo 1234567 /format json

        Args:
            line: The command line to parse
            expected_params: Dict of {param_name: required} indicating expected parameters

        Returns:
            Tuple of (parsed_params, all_required_present)
        """
        params = {}

        # Match /param value or /param "quoted value"
        patterns = [
            r'/(\w+)\s+"([^"]+)"',      # Regular double quotes
            r'/(\w+)\s+"([^"]+)"',      # Smart left/right quotes
            r'/(\w+)\s+"([^"]+)"',      # Smart quotes mixed
            r"/(\w+)\s+'([^']+)'",      # Single quotes
            r'/(\w+)\s+(\S+)',          # Unquoted values
        ]

        for pattern in patterns:
            matches = re.findall(pattern, line)
            for match in matches:
                param = match[0]
                value = match[1]
                if param not in params:
                    params[param] = value

        # Check if all required parameters are present
        all_required_present = all(
            param in params
            for param, required in expected_params.items()
            if required
        )

        return params, all_required_present

    def ensure_authenticated(self) -> bool:
        """Ensure client is authenticated, show minimal progress indicator"""
        if not self.client:
            # Check for credentials
            credential_manager = get_credential_manager()
            username, password = credential_manager.get_credentials()

            if not username or not password:
                print()
                display_credentials_note()
                return False

            try:
                # Minimal inline progress - just update status bar
                self.last_operation = "Connecting..."

                self.client = EquasisClient(username, password)
                self.logged_in = self.client.login()

                if self.logged_in:
                    self.connection_status = "Connected"
                    # Silent success - just update status bar
                    self.last_operation = ""
                else:
                    self.connection_status = "Authentication failed"
                    if self.color_support:
                        print_formatted_text(FormattedText([('class:status-disconnected', '✗ Authentication failed')]), style=self._get_style())
                    else:
                        print('✗ Authentication failed')
                    self.last_operation = "Auth failed"
                    return False

            except Exception as e:
                self.connection_status = f"Error: {e}"
                if self.color_support:
                    print_formatted_text(FormattedText([('class:status-disconnected', f'✗ Connection error: {e}')]), style=self._get_style())
                else:
                    print(f'✗ Connection error: {e}')
                self.last_operation = "Connection error"
                return False

        # Check if still logged in
        if not self.logged_in:
            self.last_operation = "Reconnecting..."
            self.logged_in = self.client.login()
            self.connection_status = "Connected" if self.logged_in else "Disconnected"
            self.last_operation = "" if self.logged_in else "Reconnect failed"

        return self.logged_in

    def _handle_output_params(self, params):
        """Handle output format and file parameters"""
        output_format = params.get('format') or self.output_format
        output_file = None

        if 'output' in params:
            output_value = params['output']
            if '.' in output_value:
                output_file = output_value
                file_ext = output_value.split('.')[-1].lower()
                if file_ext in ['json', 'csv']:
                    output_format = file_ext
            else:
                if output_value in ['table', 'json', 'csv']:
                    output_format = output_value

        if output_format not in ['table', 'json', 'csv']:
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', 'Error: Invalid format. Use table, json, or csv')]), style=self._get_style())
            else:
                print('Error: Invalid format. Use table, json, or csv')
            return None, None

        return output_format, output_file

    def _save_or_print_output(self, output, output_file, operation_name):
        """Save output to file or print to screen"""
        if output_file:
            with open(output_file, 'w') as f:
                f.write(output)
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-connected', f'✓ {operation_name} data saved to {output_file}')]), style=self._get_style())
            else:
                print(f'✓ {operation_name} data saved to {output_file}')
        else:
            print(output)

    # Command handlers
    def _cmd_vessel(self, args: str):
        """Handle vessel command"""
        if not args.strip():
            self._show_vessel_help()
            return

        expected_params = {'imo': True, 'format': False, 'output': False}
        params, all_required = self.parse_slash_command(args, expected_params)

        if not all_required:
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', 'Error: Missing required parameter /imo')]), style=self._get_style())
            else:
                print('Error: Missing required parameter /imo')
            self._show_vessel_help()
            return

        if not self.ensure_authenticated():
            return

        output_format, output_file = self._handle_output_params(params)
        if output_format is None:
            return

        try:
            # Minimal progress - just update status bar
            self.last_operation = f"Fetching IMO {params['imo']}..."

            vessel = self.client.search_vessel_by_imo(params['imo'])

            if vessel:
                output = self.formatter.format_vessel_info(vessel, output_format)
                self._save_or_print_output(output, output_file, "Vessel")

                self.last_operation = f"✓ Vessel {params['imo']} found"
            else:
                self.last_operation = f"✗ Vessel {params['imo']} not found"
                if self.color_support:
                    print_formatted_text(FormattedText([('class:status-disconnected', f'No vessel found with IMO: {params["imo"]}')]), style=self._get_style())
                else:
                    print(f'No vessel found with IMO: {params["imo"]}')

        except Exception as e:
            self.last_operation = f"✗ Error: {str(e)[:40]}"
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', f'Error: {e}')]), style=self._get_style())
            else:
                print(f'Error: {e}')

    def _cmd_search(self, args: str):
        """Handle search command"""
        if not args.strip():
            self._show_search_help()
            return

        expected_params = {'name': True, 'format': False, 'output': False}
        params, all_required = self.parse_slash_command(args, expected_params)

        if not all_required:
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', 'Error: Missing required parameter /name')]), style=self._get_style())
            else:
                print('Error: Missing required parameter /name')
            self._show_search_help()
            return

        if not self.ensure_authenticated():
            return

        output_format, output_file = self._handle_output_params(params)
        if output_format is None:
            return

        try:
            self.last_operation = f"Searching '{params['name']}'..."

            vessels = self.client.search_vessel_by_name(params['name'])

            if vessels:
                output = self.formatter.format_simple_vessel_list(vessels, output_format)
                self._save_or_print_output(output, output_file, "Search")

                self.last_operation = f"✓ Found {len(vessels)} vessel(s)"
            else:
                self.last_operation = f"✗ No vessels found"
                if self.color_support:
                    print_formatted_text(FormattedText([('class:status-disconnected', f'No vessels found matching: {params["name"]}')]), style=self._get_style())
                else:
                    print(f'No vessels found matching: {params["name"]}')

        except Exception as e:
            self.last_operation = f"✗ Error"
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', f'Error: {e}')]), style=self._get_style())
            else:
                print(f'Error: {e}')

    def _cmd_fleet(self, args: str):
        """Handle fleet command"""
        if not args.strip():
            self._show_fleet_help()
            return

        expected_params = {'company': True, 'format': False, 'output': False}
        params, all_required = self.parse_slash_command(args, expected_params)

        if not all_required:
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', 'Error: Missing required parameter /company')]), style=self._get_style())
            else:
                print('Error: Missing required parameter /company')
            self._show_fleet_help()
            return

        if not self.ensure_authenticated():
            return

        output_format, output_file = self._handle_output_params(params)
        if output_format is None:
            return

        try:
            self.last_operation = f"Fetching fleet '{params['company']}'..."

            fleet = self.client.get_fleet_info(params['company'])

            if fleet:
                output = self.formatter.format_fleet_info(fleet, output_format)
                self._save_or_print_output(output, output_file, "Fleet")

                self.last_operation = f"✓ Fleet for {params['company']} found"
            else:
                self.last_operation = f"✗ Fleet not found"
                if self.color_support:
                    print_formatted_text(FormattedText([('class:status-disconnected', f'No fleet found for company: {params["company"]}')]), style=self._get_style())
                else:
                    print(f'No fleet found for company: {params["company"]}')

        except Exception as e:
            self.last_operation = f"✗ Error"
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', f'Error: {e}')]), style=self._get_style())
            else:
                print(f'Error: {e}')

    def _cmd_batch(self, args: str):
        """Handle batch command"""
        if not args.strip():
            self._show_batch_help()
            return

        expected_params = {'imos': False, 'file': False, 'companies': False, 'company-file': False, 'format': False, 'output': False}
        params, _ = self.parse_slash_command(args, expected_params)

        # Check for valid parameter combinations
        vessel_params = ['imos', 'file']
        company_params = ['companies', 'company-file']

        vessel_provided = any(param in params for param in vessel_params)
        company_provided = any(param in params for param in company_params)

        if not vessel_provided and not company_provided:
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', 'Error: Either vessel parameters (/imos, /file) or company parameters (/companies, /company-file) are required')]), style=self._get_style())
            else:
                print('Error: Either vessel parameters (/imos, /file) or company parameters (/companies, /company-file) are required')
            self._show_batch_help()
            return

        if vessel_provided and company_provided:
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', 'Error: Cannot mix vessel and company parameters')]), style=self._get_style())
            else:
                print('Error: Cannot mix vessel and company parameters')
            return

        # Check for conflicting parameters within each type
        if sum(1 for param in vessel_params if param in params) > 1:
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', 'Error: Cannot use both /imos and /file parameters')]), style=self._get_style())
            else:
                print('Error: Cannot use both /imos and /file parameters')
            return

        if sum(1 for param in company_params if param in params) > 1:
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', 'Error: Cannot use both /companies and /company-file parameters')]), style=self._get_style())
            else:
                print('Error: Cannot use both /companies and /company-file parameters')
            return

        if not self.ensure_authenticated():
            return

        # Handle output parameters
        output_format, output_file = self._handle_output_params(params)
        if output_format is None:
            return

        # Determine processing type and get data list
        if vessel_provided:
            # Process vessels
            imo_list = []
            if 'imos' in params:
                # Parse comma-separated IMOs
                imo_list = [imo.strip() for imo in params['imos'].split(',')]
            elif 'file' in params:
                # Read IMOs from file
                imo_list = self._read_list_from_file(params['file'], "IMO numbers")
                if imo_list is None:  # Error occurred
                    return

            if not imo_list:
                if self.color_support:
                    print_formatted_text(FormattedText([('class:status-disconnected', 'Error: No IMO numbers to process')]), style=self._get_style())
                else:
                    print('Error: No IMO numbers to process')
                return

            self._process_vessel_batch(imo_list, output_format, output_file)

        elif company_provided:
            # Process companies
            company_list = []
            if 'companies' in params:
                # Parse comma-separated companies
                company_list = [company.strip() for company in params['companies'].split(',')]
            elif 'company-file' in params:
                # Read companies from file
                company_list = self._read_list_from_file(params['company-file'], "company names")
                if company_list is None:  # Error occurred
                    return

            if not company_list:
                if self.color_support:
                    print_formatted_text(FormattedText([('class:status-disconnected', 'Error: No company names to process')]), style=self._get_style())
                else:
                    print('Error: No company names to process')
                return

            self._process_company_batch(company_list, output_format, output_file)

    def _read_list_from_file(self, filename: str, data_type: str):
        """Read a list of items from file, return None on error"""
        try:
            item_list = []
            with open(filename, 'r') as f:
                for line in f:
                    line = line.strip()
                    # Skip empty lines and comments
                    if line and not line.startswith('#'):
                        item_list.append(line)
            return item_list
        except FileNotFoundError:
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', f'Error: File not found: {filename}')]), style=self._get_style())
            else:
                print(f'Error: File not found: {filename}')
            return None
        except Exception as e:
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', f'Error reading file: {e}')]), style=self._get_style())
            else:
                print(f'Error reading file: {e}')
            return None

    def _process_vessel_batch(self, imo_list, output_format, output_file):
        """Process batch of vessel IMO numbers"""
        # Progress callback function for vessels
        def progress_callback(current, total, imo, status):
            if self.color_support:
                if status == "processing":
                    print_formatted_text(FormattedText([('class:status-dim', f'⠋ [{current}/{total}] Processing IMO {imo}...')]), style=self._get_style())
                elif status == "success":
                    print_formatted_text(FormattedText([('class:status-connected', f'✓ [{current}/{total}] IMO {imo} retrieved')]), style=self._get_style())
                elif status == "not_found":
                    print_formatted_text(FormattedText([('class:status-format', f'⚠ [{current}/{total}] IMO {imo} not found')]), style=self._get_style())
                elif status == "error":
                    print_formatted_text(FormattedText([('class:status-disconnected', f'✗ [{current}/{total}] IMO {imo} error')]), style=self._get_style())
            else:
                if status == "processing":
                    print(f'[{current}/{total}] Processing IMO {imo}...')
                elif status == "success":
                    print(f'[{current}/{total}] ✓ IMO {imo} retrieved')
                elif status == "not_found":
                    print(f'[{current}/{total}] ⚠ IMO {imo} not found')
                elif status == "error":
                    print(f'[{current}/{total}] ✗ IMO {imo} error')

        try:
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-dim', f'⠋ Starting batch processing of {len(imo_list)} vessels...')]), style=self._get_style())
            else:
                print(f'Starting batch processing of {len(imo_list)} vessels...')
            print()

            # Process batch with progress callback
            results = self.client.search_vessels_by_imo_batch(
                imo_list,
                progress_callback=progress_callback,
                stop_on_error=False
            )

            print()
            output = self.formatter.format_batch_vessel_info(results, output_format)
            self._save_or_print_output(output, output_file, "Vessel Batch")

            # Summary
            successful = sum(1 for r in results if r.success)
            self.last_operation = f"✓ {successful}/{len(results)} vessels processed"
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-connected', f'✓ Vessel batch processing completed: {successful}/{len(results)} successful')]), style=self._get_style())
            else:
                print(f'✓ Vessel batch processing completed: {successful}/{len(results)} successful')
            print()

        except Exception as e:
            self.last_operation = f"✗ Batch error"
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', f'Error: {e}')]), style=self._get_style())
            else:
                print(f'Error: {e}')
            print()

    def _process_company_batch(self, company_list, output_format, output_file):
        """Process batch of company names"""
        # Progress callback function for companies
        def progress_callback(current, total, company, status):
            if self.color_support:
                if status == "processing":
                    print_formatted_text(FormattedText([('class:status-dim', f'⠋ [{current}/{total}] Processing company {company}...')]), style=self._get_style())
                elif status == "success":
                    print_formatted_text(FormattedText([('class:status-connected', f'✓ [{current}/{total}] {company} fleet retrieved')]), style=self._get_style())
                elif status == "not_found":
                    print_formatted_text(FormattedText([('class:status-format', f'⚠ [{current}/{total}] {company} not found')]), style=self._get_style())
                elif status == "error":
                    print_formatted_text(FormattedText([('class:status-disconnected', f'✗ [{current}/{total}] {company} error')]), style=self._get_style())
            else:
                if status == "processing":
                    print(f'[{current}/{total}] Processing company {company}...')
                elif status == "success":
                    print(f'[{current}/{total}] ✓ {company} fleet retrieved')
                elif status == "not_found":
                    print(f'[{current}/{total}] ⚠ {company} not found')
                elif status == "error":
                    print(f'[{current}/{total}] ✗ {company} error')

        try:
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-dim', f'⠋ Starting batch processing of {len(company_list)} companies...')]), style=self._get_style())
            else:
                print(f'Starting batch processing of {len(company_list)} companies...')
            print()

            # Process batch with progress callback
            results = self.client.search_companies_batch(
                company_list,
                progress_callback=progress_callback,
                stop_on_error=False
            )

            print()
            output = self.formatter.format_batch_fleet_info(results, output_format)
            self._save_or_print_output(output, output_file, "Company Batch")

            # Summary
            successful = sum(1 for r in results if r.success)
            total_vessels = sum(r.fleet_data.total_vessels for r in results if r.success and r.fleet_data)
            self.last_operation = f"✓ {successful}/{len(results)} companies ({total_vessels:,} vessels)"
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-connected', f'✓ Company batch processing completed: {successful}/{len(results)} companies successful ({total_vessels:,} total vessels)')]), style=self._get_style())
            else:
                print(f'✓ Company batch processing completed: {successful}/{len(results)} companies successful ({total_vessels:,} total vessels)')
            print()

        except Exception as e:
            self.last_operation = f"✗ Batch error"
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', f'Error: {e}')]), style=self._get_style())
            else:
                print(f'Error: {e}')
            print()

    def _cmd_format(self, args: str):
        """Handle format command"""
        args = args.strip().lower()
        if args in ['table', 'json', 'csv']:
            self.output_format = args
            self.last_operation = f"Format set to {args}"
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-connected', f'Default output format set to: {args}')]), style=self._get_style())
            else:
                print(f'Default output format set to: {args}')
        else:
            if self.color_support:
                print_formatted_text(FormattedText([('class:status-disconnected', 'Invalid format. Use: table, json, or csv')]), style=self._get_style())
            else:
                print('Invalid format. Use: table, json, or csv')

    def _cmd_status(self, args: str):
        """Handle status command"""
        self.last_operation = ""
        print()
        if self.color_support:
            print_formatted_text(FormattedText([('class:status-format', 'Session Status:')]), style=self._get_style())
            status_color = 'status-connected' if self.logged_in else 'status-disconnected'
            status_text = 'Connected' if self.logged_in else 'Not connected'
            print_formatted_text(FormattedText([('class:status-dim', '  Authentication: '), (f'class:{status_color}', status_text)]), style=self._get_style())
            print_formatted_text(FormattedText([('class:status-dim', '  Default Format: '), ('class:status-format', self.output_format)]), style=self._get_style())
            print_formatted_text(FormattedText([('class:status-dim', '  Debug Mode: '), ('class:status-dim', str(self.debug_mode))]), style=self._get_style())
        else:
            print('Session Status:')
            print(f'  Authentication: {"Connected" if self.logged_in else "Not connected"}')
            print(f'  Default Format: {self.output_format}')
            print(f'  Debug Mode: {self.debug_mode}')
        print()

    def _cmd_clear(self, args: str):
        """Handle clear command"""
        self.last_operation = ""
        os.system('clear' if os.name == 'posix' else 'cls')

    def _cmd_help(self, args: str):
        """Handle help command"""
        self.last_operation = ""
        if not args.strip():
            self._show_help_overlay()
        else:
            command = args.strip().lower()
            help_methods = {
                'vessel': self._show_vessel_help,
                'search': self._show_search_help,
                'fleet': self._show_fleet_help,
                'batch': self._show_batch_help,
            }
            method = help_methods.get(command)
            if method:
                method()
            else:
                print(f'No help available for: {command}')

    def _cmd_output_help(self, args: str):
        """Show output help"""
        self.last_operation = ""
        print()
        if self.color_support:
            self._print('<cyan>output</cyan> - Save command results to files')
            print()
            self._print('<dim>Usage:</dim>')
            print('  Any command can use the /output parameter:')
            print('    command [parameters] /output filename.ext')
            print('    command [parameters] /output format')
            print()
            self._print('<dim>Examples:</dim>')
            print('  vessel /imo 9074729 /output vessel_data.json')
            print('  search /name "MAERSK" /output results.csv')
            print('  fleet /company "MSC" /output fleet.json')
            print()
        else:
            print('output - Save command results to files')
            print()
            print('Usage:')
            print('  Any command can use the /output parameter:')
            print('    command [parameters] /output filename.ext')
            print('    command [parameters] /output format')
            print()
            print('Examples:')
            print('  vessel /imo 9074729 /output vessel_data.json')
            print('  search /name "MAERSK" /output results.csv')
            print('  fleet /company "MSC" /output fleet.json')
            print()

    def _cmd_exit(self, args: str):
        """Handle exit command"""
        self._do_exit()

    def _do_exit(self):
        """Exit the shell"""
        if self.color_support:
            print_formatted_text(FormattedText([('class:status-dim', 'Goodbye!')]), style=self._get_style())
        else:
            print('Goodbye!')
        self.running = False

    # Help methods
    def _show_vessel_help(self):
        """Show vessel command help"""
        print()
        if self.color_support:
            self._print('<cyan>vessel</cyan> - Get comprehensive vessel information')
            print()
            self._print('<dim>Usage:</dim>')
            print('  vessel /imo <IMO_NUMBER> [/format table|json|csv] [/output filename]')
            print()
            self._print('<dim>Examples:</dim>')
            print('  vessel /imo 9074729')
            print('  vessel /imo 8515128 /format json')
            print('  vessel /imo 9074729 /output vessel_data.json')
        else:
            print('vessel - Get comprehensive vessel information')
            print()
            print('Usage:')
            print('  vessel /imo <IMO_NUMBER> [/format table|json|csv] [/output filename]')
            print()
            print('Examples:')
            print('  vessel /imo 9074729')
            print('  vessel /imo 8515128 /format json')
            print('  vessel /imo 9074729 /output vessel_data.json')
        print()

    def _show_search_help(self):
        """Show search command help"""
        print()
        if self.color_support:
            self._print('<cyan>search</cyan> - Search for vessels by name')
            print()
            self._print('<dim>Usage:</dim>')
            print('  search /name "<VESSEL_NAME>" [/format table|json|csv]')
            print()
            self._print('<dim>Examples:</dim>')
            print('  search /name "MAERSK"')
            print('  search /name "EVER GIVEN" /format json')
        else:
            print('search - Search for vessels by name')
            print()
            print('Usage:')
            print('  search /name "<VESSEL_NAME>" [/format table|json|csv]')
            print()
            print('Examples:')
            print('  search /name "MAERSK"')
            print('  search /name "EVER GIVEN" /format json')
        print()

    def _show_fleet_help(self):
        """Show fleet command help"""
        print()
        if self.color_support:
            self._print('<cyan>fleet</cyan> - Get fleet information for a company')
            print()
            self._print('<dim>Usage:</dim>')
            print('  fleet /company "<COMPANY_NAME>" [/format table|json|csv] [/output filename]')
            print()
            self._print('<dim>Examples:</dim>')
            print('  fleet /company "MAERSK LINE"')
            print('  fleet /company "MSC" /format json')
            print('  fleet /company "COSCO" /output fleet.json')
            print()
            self._print('<dim>Parameters:</dim>')
            print('  /company  Company name (required)')
            print('  /format   Output format: table, json, csv (optional)')
            print('  /output   Save to file or specify format (optional)')
        else:
            print('fleet - Get fleet information for a company')
            print()
            print('Usage:')
            print('  fleet /company "<COMPANY_NAME>" [/format table|json|csv] [/output filename]')
            print()
            print('Examples:')
            print('  fleet /company "MAERSK LINE"')
            print('  fleet /company "MSC" /format json')
            print('  fleet /company "COSCO" /output fleet.json')
            print()
            print('Parameters:')
            print('  /company  Company name (required)')
            print('  /format   Output format: table, json, csv (optional)')
            print('  /output   Save to file or specify format (optional)')
        print()

    def _show_batch_help(self):
        """Show batch command help"""
        print()
        if self.color_support:
            self._print('<cyan>batch</cyan> - Process multiple vessels or companies')
            print()
            self._print('<dim>Usage:</dim>')
            print('  batch /imos "IMO1,IMO2,IMO3" [/format table|json|csv] [/output filename]')
            print('  batch /file filename.txt [/format table|json|csv] [/output filename]')
            print('  batch /companies "Company1,Company2" [/format table|json|csv] [/output filename]')
            print('  batch /company-file companies.txt [/format table|json|csv] [/output filename]')
            print()
            self._print('<dim>Examples:</dim>')
            print('  batch /imos "9074729,8515128,9632179"')
            print('  batch /file fleet_imos.txt /format json')
            print('  batch /companies "MSC,MAERSK LINE,COSCO"')
            print('  batch /company-file major_carriers.txt /output results.csv')
            print()
            self._print('<dim>Parameters:</dim>')
            print('  /imos         Comma-separated IMO numbers (use this OR /file)')
            print('  /file         File containing IMO numbers, one per line (use this OR /imos)')
            print('  /companies    Comma-separated company names (use this OR /company-file)')
            print('  /company-file File containing company names, one per line (use this OR /companies)')
            print('  /format       Output format: table, json, csv (optional)')
            print('  /output       Save to file (optional)')
            print()
            self._print('<dim>File Format:</dim>')
            print('  Text file with one IMO/company per line')
            print('  Lines starting with # are treated as comments')
            print('  Empty lines are ignored')
        else:
            print('batch - Process multiple vessels or companies')
            print()
            print('Usage:')
            print('  batch /imos "IMO1,IMO2,IMO3" [/format table|json|csv] [/output filename]')
            print('  batch /file filename.txt [/format table|json|csv] [/output filename]')
            print('  batch /companies "Company1,Company2" [/format table|json|csv] [/output filename]')
            print('  batch /company-file companies.txt [/format table|json|csv] [/output filename]')
            print()
            print('Examples:')
            print('  batch /imos "9074729,8515128,9632179"')
            print('  batch /file fleet_imos.txt /format json')
            print('  batch /companies "MSC,MAERSK LINE,COSCO"')
            print('  batch /company-file major_carriers.txt /output results.csv')
            print()
            print('Parameters:')
            print('  /imos         Comma-separated IMO numbers (use this OR /file)')
            print('  /file         File containing IMO numbers, one per line (use this OR /imos)')
            print('  /companies    Comma-separated company names (use this OR /company-file)')
            print('  /company-file File containing company names, one per line (use this OR /companies)')
            print('  /format       Output format: table, json, csv (optional)')
            print('  /output       Save to file (optional)')
            print()
            print('File Format:')
            print('  Text file with one IMO/company per line')
            print('  Lines starting with # are treated as comments')
            print('  Empty lines are ignored')
        print()


def main():
    """Entry point for interactive shell"""
    shell = InteractiveShell()
    shell.start()


if __name__ == '__main__':
    main()